export default {
  name: 'Complex TypeScript ES module with advanced types and async generators',
  sourceCode: [
    '// File: ingest-and-compress.ts',
    '// TypeScript (no decorators, no `satisfies`, no `import { type ... }`)',
    '',
    "import * as fs from 'fs';",
    "import * as fsp from 'fs/promises';",
    "import * as path from 'path';",
    "import * as zlib from 'zlib';",
    "import { pipeline } from 'stream';",
    "import { promisify } from 'util';",
    "import { createHash } from 'crypto';",
    '',
    'const pipe = promisify(pipeline);',
    '',
    'type ResultOk = { file: string; gz: string; sha1: string; ok: true };',
    'type ResultErr = { file: string; error: string; ok: false };',
    'type Result = ResultOk | ResultErr;',
    '',
    'enum Ext {',
    "  JS = 'js', TS = 'ts', JSON = 'json', MD = 'md', TXT = 'txt', CSS = 'css', HTML = 'html', CJS = 'cjs', MJS = 'mjs'",
    '}',
    '',
    '// Tiny generic concurrency limiter',
    'function pLimit<T>(n: number) {',
    '  const q: Array<() => void> = [];',
    '  let active = 0;',
    '  const next = () => { active--; if (q.length) q.shift()!(); };',
    '  return (fn: () => Promise<T>): Promise<T> =>',
    '    new Promise((resolve, reject) => {',
    '      const run = async () => {',
    '        active++;',
    '        try { resolve(await fn()); }',
    '        catch (e) { reject(e); }',
    '        finally { next(); }',
    '      };',
    '      active < n ? run() : q.push(run);',
    '    });',
    '}',
    '',
    'const limit = pLimit<Result>(4);',
    '',
    'async function ensureDir(dir: string) {',
    '  await fsp.mkdir(dir, { recursive: true });',
    '}',
    '',
    'async function* walk(dir: string): AsyncGenerator<string> {',
    '  for (const entry of await fsp.readdir(dir, { withFileTypes: true })) {',
    '    const full = path.join(dir, entry.name);',
    '    if (entry.isDirectory()) {',
    "      if (['node_modules', '.git', 'dist', 'build', '.next'].includes(entry.name)) continue;",
    '      yield* walk(full);',
    '    } else {',
    '      yield full;',
    '    }',
    '  }',
    '}',
    '',
    'function isAllowedFile(file: string, size: number): boolean {',
    '  if (size > 1_000_000) return false;',
    '  const m = /\\.(\\w+)$/.exec(file);',
    "  const ext = (m?.[1] ?? '').toLowerCase() as keyof typeof Ext;",
    '  return (Ext as any)[ext] != null;',
    '}',
    '',
    'async function compressFile(src: string, destDir: string): Promise<string> {',
    '  const base = path.basename(src);',
    '  const out = path.join(destDir, `${base}.gz`);',
    '  await ensureDir(destDir);',
    '',
    '  const read = fs.createReadStream(src);',
    '  const gzip = zlib.createGzip({ level: zlib.constants.Z_BEST_SPEED });',
    '  const write = fs.createWriteStream(out);',
    '',
    '  await pipe(read, gzip, write);',
    '  return out;',
    '}',
    '',
    'async function sha1(filePath: string): Promise<string> {',
    "  const hash = createHash('sha1');",
    '  const read = fs.createReadStream(filePath);',
    '  await pipe(read, hash as any); // stream.Hash is duplex; cast to satisfy pipeline typings',
    "  return hash.digest('hex');",
    '}',
    '',
    'async function main(argv = process.argv): Promise<void> {',
    "  const [, , inputDir = '.', outputDir = './.artifacts'] = argv;",
    '  const started = Date.now();',
    '',
    '  const absIn = path.resolve(inputDir);',
    '  const files: string[] = [];',
    '  for await (const file of walk(absIn)) {',
    '    const { size } = await fsp.stat(file);',
    '    if (!isAllowedFile(file, size)) continue;',
    '    files.push(file);',
    '  }',
    '',
    '  if (!files.length) {',
    '    console.log(`No candidate files found in ${inputDir}`);',
    '    return;',
    '  }',
    '',
    '  const results = await Promise.all(',
    '    files.map((f) =>',
    '      limit(async (): Promise<Result> => {',
    '        try {',
    '          const gz = await compressFile(f, outputDir);',
    '          const sum = await sha1(gz);',
    '          return { file: f, gz, sha1: sum, ok: true };',
    '        } catch (e: any) {',
    '          return { file: f, error: e?.message ?? String(e), ok: false };',
    '        }',
    '      })',
    '    )',
    '  );',
    '',
    '  const ok = results.filter((r): r is ResultOk => r.ok).length;',
    '  const fail = results.length - ok;',
    '  const took = ((Date.now() - started) / 1000).toFixed(2);',
    '',
    '  console.log(',
    '    `Processed ${results.length} files (${ok} ok, ${fail} failed) in ${took}s â†’ ${path.resolve(outputDir)}`',
    '  );',
    '',
    '  // Write a manifest',
    '  const manifest = results.map((r) => ({',
    '    file: r.file,',
    '    gz: (r as ResultOk).gz ?? null,',
    '    sha1: (r as ResultOk).sha1 ?? null,',
    '    ok: r.ok,',
    '  }));',
    '  await ensureDir(outputDir);',
    "  await fsp.writeFile(path.join(outputDir, 'manifest.json'), JSON.stringify(manifest, null, 2));",
    '}',
    '',
    'if (require.main === module) {',
    '  main().catch((e) => {',
    "    console.error('Fatal error:', e?.stack ?? e);",
    '    process.exitCode = 1;',
    '  });',
    '}',
  ],
};
