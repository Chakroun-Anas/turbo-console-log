export default {
  name: 'Complex Node.js CommonJS script with async/await and streams',
  sourceCode: [
    '// File: ingest-and-compress.js',
    '// Node.js (CommonJS) — medium complexity, no external deps',
    '',
    "const fs = require('fs');",
    "const fsp = require('fs/promises');",
    "const path = require('path');",
    "const zlib = require('zlib');",
    "const { pipeline } = require('stream');",
    "const { promisify } = require('util');",
    '',
    'const pipe = promisify(pipeline);',
    '',
    '// Tiny concurrency limiter (no deps)',
    'function pLimit(n) {',
    '  const q = [];',
    '  let active = 0;',
    '  const next = () => {',
    '    active--;',
    '    if (q.length) q.shift()();',
    '  };',
    '  return (fn) =>',
    '    new Promise((resolve, reject) => {',
    '      const run = async () => {',
    '        active++;',
    '        try {',
    '          resolve(await fn());',
    '        } catch (e) {',
    '          reject(e);',
    '        } finally {',
    '          next();',
    '        }',
    '      };',
    '      active < n ? run() : q.push(run);',
    '    });',
    '}',
    '',
    'const limit = pLimit(4);',
    '',
    'async function ensureDir(dir) {',
    '  await fsp.mkdir(dir, { recursive: true });',
    '}',
    '',
    'async function* walk(dir) {',
    '  for (const entry of await fsp.readdir(dir, { withFileTypes: true })) {',
    '    const full = path.join(dir, entry.name);',
    '    if (entry.isDirectory()) {',
    '      // ignore common junk',
    "      if (['node_modules', '.git', 'dist', 'build', '.next'].includes(entry.name)) continue;",
    '      yield* walk(full);',
    '    } else {',
    '      yield full;',
    '    }',
    '  }',
    '}',
    '',
    'async function compressFile(src, destDir) {',
    '  const base = path.basename(src);',
    '  const out = path.join(destDir, `${base}.gz`);',
    '  await ensureDir(destDir);',
    '',
    '  const read = fs.createReadStream(src);',
    '  const gzip = zlib.createGzip({ level: zlib.constants.Z_BEST_SPEED });',
    '  const write = fs.createWriteStream(out);',
    '',
    '  await pipe(read, gzip, write);',
    '  return out;',
    '}',
    '',
    'async function sha1(filePath) {',
    "  const { createHash } = require('crypto');",
    "  const hash = createHash('sha1');",
    '  const read = fs.createReadStream(filePath);',
    '  await pipe(read, hash);',
    "  return hash.digest('hex');",
    '}',
    '',
    'async function main() {',
    "  const [,, inputDir = '.', outputDir = './.artifacts'] = process.argv;",
    '  const started = Date.now();',
    '',
    '  const files = [];',
    '  for await (const file of walk(path.resolve(inputDir))) {',
    '    // only take text-like files under 1 MB',
    '    const { size } = await fsp.stat(file);',
    '    if (size > 1_000_000) continue;',
    '    if (!/\\.(js|ts|json|md|txt|css|html|cjs|mjs)$/i.test(file)) continue;',
    '    files.push(file);',
    '  }',
    '',
    '  if (!files.length) {',
    '    console.log(`No candidate files found in ${inputDir}`);',
    '    return;',
    '  }',
    '',
    '  const results = await Promise.all(',
    '    files.map((f) =>',
    '      limit(async () => {',
    '        try {',
    '          const gz = await compressFile(f, outputDir);',
    '          const sum = await sha1(gz);',
    '          return { file: f, gz, sha1: sum, ok: true };',
    '        } catch (e) {',
    '          return { file: f, error: e?.message ?? String(e), ok: false };',
    '        }',
    '      })',
    '    )',
    '  );',
    '',
    '  const ok = results.filter(r => r.ok).length;',
    '  const fail = results.length - ok;',
    '  const took = ((Date.now() - started) / 1000).toFixed(2);',
    '',
    '  console.log(',
    '    `Processed ${results.length} files (${ok} ok, ${fail} failed) in ${took}s → ${path.resolve(outputDir)}`',
    '  );',
    '',
    '  // Write a small manifest',
    '  const manifest = results.map(r => ({',
    '    file: r.file,',
    '    gz: r.gz ?? null,',
    '    sha1: r.sha1 ?? null,',
    '    ok: r.ok,',
    '  }));',
    '  await ensureDir(outputDir);',
    "  await fsp.writeFile(path.join(outputDir, 'manifest.json'), JSON.stringify(manifest, null, 2));",
    '}',
    '',
    'if (require.main === module) {',
    '  main().catch((e) => {',
    "    console.error('Fatal error:', e?.stack ?? e);",
    '    process.exitCode = 1;',
    '  });',
    '}',
  ],
};
